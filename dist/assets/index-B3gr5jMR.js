var a=Object.defineProperty;var d=(o,e,t)=>e in o?a(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var n=(o,e,t)=>d(o,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const c of s.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&i(c)}).observe(document,{childList:!0,subtree:!0});function t(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(r){if(r.ep)return;r.ep=!0;const s=t(r);fetch(r.href,s)}})();class h{constructor(e){this.shadowRoot=e}async render(){try{const[e,t]=await Promise.all([this.fetchResource("./UrdTimer.css"),this.fetchResource("./UrdTimer.html")]);this.shadowRoot&&(this.shadowRoot.innerHTML=`<style>${e}</style>${t}`)}catch(e){console.error("Error in render:",e)}}addButtonListeners(e,t){var s,c;const i=(s=this.shadowRoot)==null?void 0:s.querySelector("#start-stop"),r=(c=this.shadowRoot)==null?void 0:c.querySelector("#reset");i&&r?(i.addEventListener("click",e),r.addEventListener("click",t)):console.error("Buttons not found in the shadow DOM")}update(e,t){this.updateDisplay(e),this.updateStartStopButton(t?"Pause":"Start")}updateDisplay(e){var i;const t=(i=this.shadowRoot)==null?void 0:i.querySelector("#time-display");t&&(t.textContent=this.formatTime(e))}updateStartStopButton(e){var i;const t=(i=this.shadowRoot)==null?void 0:i.querySelector("#start-stop");t&&(t.textContent=e)}formatTime(e){const t=Math.floor(e/60),i=e%60;return`${t.toString().padStart(2,"0")}:${i.toString().padStart(2,"0")}`}async fetchResource(e){const t=await fetch(new URL(e,import.meta.url));if(!t.ok)throw new Error(`Failed to fetch ${e}: ${t.statusText}`);return t.text()}}class u{constructor(){n(this,"timer",null);n(this,"timeLeft",25*60);n(this,"isWorking",!0);n(this,"observers",[])}addObserver(e){this.observers.push(e)}removeObserver(e){const t=this.observers.indexOf(e);t>-1&&this.observers.splice(t,1)}notifyObservers(){for(const e of this.observers)e.update(this.timeLeft,this.isWorking)}toggle(){this.timer?this.pause():this.start()}reset(){this.pause(),this.timeLeft=25*60,this.isWorking=!0,this.notifyObservers()}start(){this.timer=window.setInterval(()=>{this.timeLeft--,this.notifyObservers(),this.timeLeft<=0&&this.switchMode()},1e3)}pause(){this.timer&&(window.clearInterval(this.timer),this.timer=null),this.notifyObservers()}switchMode(){this.isWorking=!this.isWorking,this.timeLeft=this.isWorking?25*60:5*60,this.notifyObservers(),this.notifyUser()}notifyUser(){Notification.permission==="granted"&&new Notification(this.isWorking?"Dags att arbeta!":"Dags fÃ¶r en paus!")}}class l extends HTMLElement{constructor(){super();n(this,"urdUIService");n(this,"urdTimerService");this.attachShadow({mode:"open"}),this.urdTimerService=new u,this.urdUIService=new h(this.shadowRoot),this.urdTimerService.addObserver(this.urdUIService)}async connectedCallback(){try{await this.urdUIService.render(),this.addEventListeners()}catch(t){console.error("Error in connectedCallback:",t)}}addEventListeners(){this.urdUIService.addButtonListeners(()=>this.urdTimerService.toggle(),()=>this.urdTimerService.reset())}}customElements.get("urd-timer")||customElements.define("urd-timer",l);console.log("Urd Timekeeper initialized");
